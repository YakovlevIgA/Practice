// На планете началась вечная зима, теперь выпавший снег совсем перестал таять.
// Каждый день выпадает несколько миллиметров снега, после чего метеостанция замеряет глубину снега в одном месте
// и записывает её на отдельный лист в журнал. Достоверно известно, что перед первым днем замеров снега не было вовсе,
// а далее на протяжении всего периода замеров за день выпадало положительное целое число миллиметров снега.
// Вы получили в распоряжение журнал, чтобы проверить, не допустили ли ошибку на метеостанции при заполнении
// по случайности или из злого умысла. Но перед его изучением решили выпить чашечку кофе (вечная зима на дворе!)
// и случайно разлили его на журнал. В результате чего на некоторых его листах оказались неразличимые кляксы.
// Теперь вы просто хотите найти количество снега в миллиметрах, которое могло выпасть в каждый день замера или обличить
// метеостанцию в подтасовке, если по испорченному журналу можно достоверно сказать, что данные фальсифицированы.
// Среди всех вариантов ответа вас устроит любой, главное, чтобы он согласовывался с сохранившимися данными
// из испорченного журнала.

// Формат входных данных
// В первой строке входных данных содержится число n (1 < n < 10000000) — количество дней, на протяжении которых проводились
// замеры. Во второй строке содержатся п целых чисел а(i), разделенных пробелом. а(i) равно - 1, если
// соответствующий лист нечитаемый, а иначе это число, записанное на 2-м листе, в этом случае а не превосходит 100000000.

// Формат выходных данных
// Если в журнале была допущена ошибка, выведите «NO» (без кавычек).
// В противном случае, в первой строке выведите «YES», а во второй строке выведите n натуральных чисел от 1 до 100000000,
// i-е из которых равняется количеству выпавшего снега в i-й день.

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func validateAndRestoreLog(n int, arr []int) (bool, []int) {
	// Заполнение недостающих значений
	for i := 0; i < len(arr); i++ {
		if arr[i] == -1 {
			if i == 0 {
				arr[i] = 1
			} else {
				arr[i] = arr[i-1] + 1
			}
		}
	}

	// Проверка на подлог
	for i := 1; i < len(arr); i++ {
		if arr[i] <= arr[i-1] {
			return false, nil
		}
	}

	// Вычисление осадков
	osadki := make([]int, len(arr))
	for i := 0; i < len(arr); i++ {
		if i == 0 {
			osadki[i] = arr[i]
		} else {
			osadki[i] = arr[i] - arr[i-1]
		}
	}

	return true, osadki
}

func main() {
	reader := bufio.NewReader(os.Stdin)

	firstLine, _ := reader.ReadString('\n')
	firstLine = strings.TrimSpace(firstLine)
	n, _ := strconv.Atoi(firstLine)

	secondLine, _ := reader.ReadString('\n')
	secondLine = strings.TrimSpace(secondLine)

	inputs := strings.Fields(secondLine)

	measurements := make([]int, n)

	for i := 0; i < n; i++ {
		measurements[i], _ = strconv.Atoi(inputs[i])
	}

	check, result := validateAndRestoreLog(n, measurements)
	switch {
	case check == true:
		fmt.Println("YES")
		strNumbers := make([]string, len(result))
		for i, num := range result {
			strNumbers[i] = strconv.Itoa(num)
		}
		result := strings.Join(strNumbers, " ")
		fmt.Println(result)
	case check == false:
		fmt.Println("NO")
	}
}
